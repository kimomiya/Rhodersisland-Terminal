// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides

part of 'stage.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more informations: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
class _$StageTearOff {
  const _$StageTearOff();

  _Stage call(
      {required UniqueId id,
      required String zoneId,
      required String code,
      required String type,
      required int apCost,
      required KtList<DropInfo> dropInfos,
      required KtMap<Server, Existence> existence,
      DateTime? minClearTime,
      required KtMap<I18n, String> codeI18n}) {
    return _Stage(
      id: id,
      zoneId: zoneId,
      code: code,
      type: type,
      apCost: apCost,
      dropInfos: dropInfos,
      existence: existence,
      minClearTime: minClearTime,
      codeI18n: codeI18n,
    );
  }
}

/// @nodoc
const $Stage = _$StageTearOff();

/// @nodoc
mixin _$Stage {
  UniqueId get id => throw _privateConstructorUsedError;
  String get zoneId => throw _privateConstructorUsedError;
  String get code => throw _privateConstructorUsedError;
  String get type => throw _privateConstructorUsedError;
  int get apCost => throw _privateConstructorUsedError;
  KtList<DropInfo> get dropInfos => throw _privateConstructorUsedError;
  KtMap<Server, Existence> get existence => throw _privateConstructorUsedError;
  DateTime? get minClearTime => throw _privateConstructorUsedError;
  KtMap<I18n, String> get codeI18n => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $StageCopyWith<Stage> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $StageCopyWith<$Res> {
  factory $StageCopyWith(Stage value, $Res Function(Stage) then) =
      _$StageCopyWithImpl<$Res>;
  $Res call(
      {UniqueId id,
      String zoneId,
      String code,
      String type,
      int apCost,
      KtList<DropInfo> dropInfos,
      KtMap<Server, Existence> existence,
      DateTime? minClearTime,
      KtMap<I18n, String> codeI18n});
}

/// @nodoc
class _$StageCopyWithImpl<$Res> implements $StageCopyWith<$Res> {
  _$StageCopyWithImpl(this._value, this._then);

  final Stage _value;
  // ignore: unused_field
  final $Res Function(Stage) _then;

  @override
  $Res call({
    Object? id = freezed,
    Object? zoneId = freezed,
    Object? code = freezed,
    Object? type = freezed,
    Object? apCost = freezed,
    Object? dropInfos = freezed,
    Object? existence = freezed,
    Object? minClearTime = freezed,
    Object? codeI18n = freezed,
  }) {
    return _then(_value.copyWith(
      id: id == freezed
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as UniqueId,
      zoneId: zoneId == freezed
          ? _value.zoneId
          : zoneId // ignore: cast_nullable_to_non_nullable
              as String,
      code: code == freezed
          ? _value.code
          : code // ignore: cast_nullable_to_non_nullable
              as String,
      type: type == freezed
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as String,
      apCost: apCost == freezed
          ? _value.apCost
          : apCost // ignore: cast_nullable_to_non_nullable
              as int,
      dropInfos: dropInfos == freezed
          ? _value.dropInfos
          : dropInfos // ignore: cast_nullable_to_non_nullable
              as KtList<DropInfo>,
      existence: existence == freezed
          ? _value.existence
          : existence // ignore: cast_nullable_to_non_nullable
              as KtMap<Server, Existence>,
      minClearTime: minClearTime == freezed
          ? _value.minClearTime
          : minClearTime // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      codeI18n: codeI18n == freezed
          ? _value.codeI18n
          : codeI18n // ignore: cast_nullable_to_non_nullable
              as KtMap<I18n, String>,
    ));
  }
}

/// @nodoc
abstract class _$StageCopyWith<$Res> implements $StageCopyWith<$Res> {
  factory _$StageCopyWith(_Stage value, $Res Function(_Stage) then) =
      __$StageCopyWithImpl<$Res>;
  @override
  $Res call(
      {UniqueId id,
      String zoneId,
      String code,
      String type,
      int apCost,
      KtList<DropInfo> dropInfos,
      KtMap<Server, Existence> existence,
      DateTime? minClearTime,
      KtMap<I18n, String> codeI18n});
}

/// @nodoc
class __$StageCopyWithImpl<$Res> extends _$StageCopyWithImpl<$Res>
    implements _$StageCopyWith<$Res> {
  __$StageCopyWithImpl(_Stage _value, $Res Function(_Stage) _then)
      : super(_value, (v) => _then(v as _Stage));

  @override
  _Stage get _value => super._value as _Stage;

  @override
  $Res call({
    Object? id = freezed,
    Object? zoneId = freezed,
    Object? code = freezed,
    Object? type = freezed,
    Object? apCost = freezed,
    Object? dropInfos = freezed,
    Object? existence = freezed,
    Object? minClearTime = freezed,
    Object? codeI18n = freezed,
  }) {
    return _then(_Stage(
      id: id == freezed
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as UniqueId,
      zoneId: zoneId == freezed
          ? _value.zoneId
          : zoneId // ignore: cast_nullable_to_non_nullable
              as String,
      code: code == freezed
          ? _value.code
          : code // ignore: cast_nullable_to_non_nullable
              as String,
      type: type == freezed
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as String,
      apCost: apCost == freezed
          ? _value.apCost
          : apCost // ignore: cast_nullable_to_non_nullable
              as int,
      dropInfos: dropInfos == freezed
          ? _value.dropInfos
          : dropInfos // ignore: cast_nullable_to_non_nullable
              as KtList<DropInfo>,
      existence: existence == freezed
          ? _value.existence
          : existence // ignore: cast_nullable_to_non_nullable
              as KtMap<Server, Existence>,
      minClearTime: minClearTime == freezed
          ? _value.minClearTime
          : minClearTime // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      codeI18n: codeI18n == freezed
          ? _value.codeI18n
          : codeI18n // ignore: cast_nullable_to_non_nullable
              as KtMap<I18n, String>,
    ));
  }
}

/// @nodoc
class _$_Stage implements _Stage {
  const _$_Stage(
      {required this.id,
      required this.zoneId,
      required this.code,
      required this.type,
      required this.apCost,
      required this.dropInfos,
      required this.existence,
      this.minClearTime,
      required this.codeI18n});

  @override
  final UniqueId id;
  @override
  final String zoneId;
  @override
  final String code;
  @override
  final String type;
  @override
  final int apCost;
  @override
  final KtList<DropInfo> dropInfos;
  @override
  final KtMap<Server, Existence> existence;
  @override
  final DateTime? minClearTime;
  @override
  final KtMap<I18n, String> codeI18n;

  @override
  String toString() {
    return 'Stage(id: $id, zoneId: $zoneId, code: $code, type: $type, apCost: $apCost, dropInfos: $dropInfos, existence: $existence, minClearTime: $minClearTime, codeI18n: $codeI18n)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _Stage &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.zoneId, zoneId) ||
                const DeepCollectionEquality().equals(other.zoneId, zoneId)) &&
            (identical(other.code, code) ||
                const DeepCollectionEquality().equals(other.code, code)) &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.apCost, apCost) ||
                const DeepCollectionEquality().equals(other.apCost, apCost)) &&
            (identical(other.dropInfos, dropInfos) ||
                const DeepCollectionEquality()
                    .equals(other.dropInfos, dropInfos)) &&
            (identical(other.existence, existence) ||
                const DeepCollectionEquality()
                    .equals(other.existence, existence)) &&
            (identical(other.minClearTime, minClearTime) ||
                const DeepCollectionEquality()
                    .equals(other.minClearTime, minClearTime)) &&
            (identical(other.codeI18n, codeI18n) ||
                const DeepCollectionEquality()
                    .equals(other.codeI18n, codeI18n)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(zoneId) ^
      const DeepCollectionEquality().hash(code) ^
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(apCost) ^
      const DeepCollectionEquality().hash(dropInfos) ^
      const DeepCollectionEquality().hash(existence) ^
      const DeepCollectionEquality().hash(minClearTime) ^
      const DeepCollectionEquality().hash(codeI18n);

  @JsonKey(ignore: true)
  @override
  _$StageCopyWith<_Stage> get copyWith =>
      __$StageCopyWithImpl<_Stage>(this, _$identity);
}

abstract class _Stage implements Stage {
  const factory _Stage(
      {required UniqueId id,
      required String zoneId,
      required String code,
      required String type,
      required int apCost,
      required KtList<DropInfo> dropInfos,
      required KtMap<Server, Existence> existence,
      DateTime? minClearTime,
      required KtMap<I18n, String> codeI18n}) = _$_Stage;

  @override
  UniqueId get id => throw _privateConstructorUsedError;
  @override
  String get zoneId => throw _privateConstructorUsedError;
  @override
  String get code => throw _privateConstructorUsedError;
  @override
  String get type => throw _privateConstructorUsedError;
  @override
  int get apCost => throw _privateConstructorUsedError;
  @override
  KtList<DropInfo> get dropInfos => throw _privateConstructorUsedError;
  @override
  KtMap<Server, Existence> get existence => throw _privateConstructorUsedError;
  @override
  DateTime? get minClearTime => throw _privateConstructorUsedError;
  @override
  KtMap<I18n, String> get codeI18n => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  _$StageCopyWith<_Stage> get copyWith => throw _privateConstructorUsedError;
}
